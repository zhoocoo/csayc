---
title: js如何封装一个前端http并发请求池的库？
description: HTTP/1.1最多只允许同时建立6个TCP持久链接数，这导致我们不得不进行http请求的并发控制，本文将讲解，如何封装一个并发控制库；
categories:
  - 前端优化
image:
  src: https://article-1256327087.cos.ap-beijing.myqcloud.com/anchor/poster.png
  alt: 前端优化
  width: 1024
  height: 576
tags:
  - parelle
  - HTTP/1.1
navigation:
  title: js如何封装一个前端http并发请求池的库？
  description: HTTP/1.1最多只允许同时建立6个TCP持久链接数，这导致我们不得不进行http请求的并发控制，本文将讲解，如何封装一个并发控制库；
  poster:
    src: https://article-1256327087.cos.ap-beijing.myqcloud.com/anchor/poster.png
    width: 1024
    height: 576
  tags:
    - parelle
    - HTTP/1.1
---

## 并发控制介绍

HTTP/1.1最多只允许同时建立6个TCP持久链接数，这导致我们不得不进行http请求的并发控制，本文将讲解，如何封装一个并发控制库；

### 背景
`HTTP/1.1`太过于经典和强势，导致大多数网站使用的仍然使用它。

而`HTTP/1.1`在大多数浏览器中，针对于同一个域名，默认最多只允许同时建立6个TCP持久链接数。

这导致了当浏览器发起一个请求的时候，如果已经有了6个处于忙碌状态的TCP连接，那么这个请求便会处于排队状态。

所以，当我们的请求过多时，`HTTP/1.1`协议将极大地影响页面性能，阻塞别的网络请求，很有可能导致别的请求超时报错。

当然，除了进行请求的并发控制外，我们还能通过别的方法避免这些问题吗？
- 我们可以通过**域名分片**技术提高页面性能，将站点下的重要资源，放到不同域名的CDN下，比如放到3个域名下，这样便可以同时支持18个TCP连接了。
- 当然，最好的方案是升级到`HTTP/2`，因为`HTTP/2`已经没有了每个域名最多维护6个TCP连接的限制了，一劳永逸！

针对于`HTTP/1.1`的协议，在遇到过多HTTP请求时，在不采用别的方案前提下，则需要对请求进行并发控制。


## 思路讲解

核心要点有三个：
- 通过`Promise.allSettled`来返回每一组异步返回值；
- 通过`Promise.race`和`async/await`来控制并行数量上限；

### 流程图

### 代码实现

## async-pool

### 如何使用

### 垫片polyfill

## 参考

- [HTTP - 1. HTTP 的发展历程](https://www.cnblogs.com/liyf-98/p/14416131.html)
- [async-pool](https://github.com/rxaviers/async-pool)