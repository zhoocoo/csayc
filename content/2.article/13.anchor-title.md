---
title: 📌vue3如何实现一个简单的锚点目录定位
description: 锚记链接使你能够精确地控制访问者在其中单击超链接之后到达的位置。没有命名锚记的链接将把访问者带到目标网页的顶端。当页面中的文章很长时，仅靠上下移动滚动条寻找需要的部分比较麻烦，这时可以创建页面内的超级链接，以便迅速找到需要的资料。
categories:
  - 前端优化
image:
  src: https://article-1256327087.cos.ap-beijing.myqcloud.com/anchor/d1160924ab18972bd40725d051996c899e510fb39cd7.png
  alt: 前端优化
  width: 1024
  height: 576
tags:
  - optimize
  - image
navigation:
  title: 📌vue3如何实现一个简单的锚点目录定位
  description: 锚记链接使你能够精确地控制访问者在其中单击超链接之后到达的位置。没有命名锚记的链接将把访问者带到目标网页的顶端。当页面中的文章很长时，仅靠上下移动滚动条寻找需要的部分比较麻烦，这时可以创建页面内的超级链接，以便迅速找到需要的资料。
  poster:
    src: https://article-1256327087.cos.ap-beijing.myqcloud.com/anchor/d1160924ab18972bd40725d051996c899e510fb39cd7.png
    width: 1024
    height: 576
  tags:
    - optimize
    - scroll
---

## 前言

本文将使用`vue3`编写一个锚点目录定位功能，并逐个分析其中的实现坑点。在这篇文章中你将会学到什么？

- 什么是锚点目录定位
- 锚点定位被顶部固定导航栏遮住的解决方案
- 锚点定位的优化
- `vue3`如何实现目录导航的锚点定位功能

## 简介

首先，**锚点目录定位**是什么？

锚点目录定位分为两部分：

1.  [锚记链接](https://baike.baidu.com/item/%E9%94%9A%E8%AE%B0%E9%93%BE%E6%8E%A5/6075238?fromtitle=%E5%91%BD%E5%90%8D%E9%94%9A%E8%AE%B0&fromid=7589624)，如 `http://www.csayc.com/article/vmodel#方式一通过watch中转` ，此链接中 `#方式一通过watch中转` 即为**锚链**，而`html`中带有以此锚链作为`id`的`Element`元素，则称为**锚点**；在我们访问当前链接时，可以精确地控制页面直接到达当前位置。

![image](https://article-1256327087.cos.ap-beijing.myqcloud.com/anchor/iShot_2023-02-03_15.16.03.gif)

2.  **目录定位**，页面滚动实时激活目录，即当我们滚动页面时，目录将会实时被激活，而点击目录时，会自动滚动到当前目录对应内容的起始位置；

![image](https://article-1256327087.cos.ap-beijing.myqcloud.com/anchor/iShot_2023-02-03_15.47.58.gif)

## 锚记链接

一个简单的锚记链接，由**锚点**(`indicated part`)以及**锚链**(`fragment`)组成；其中锚链为`url`地址中的`#`部分，即我们所熟悉的`location.hash`。锚点则为文档流中，第一个`Element`的`id`属性等于锚链的节点；

以下链接便是一个带有**锚链**的`URL`链接，锚链也称为[`fragment`](https://url.spec.whatwg.org/#concept-url-fragment)

```bash
http://www.xxx.com/#anchor  // location.hash=anchor，其为锚链（fragment）
```

锚点则为`html`中的`<h2 id='anchor'></h2>`元素。

通过访问带有锚链的链接，我们便能够直接使得页面定位至锚点所在位置；

### 基础实现

查看以下示例代码，`html`中带有两个**锚点**，`anchor1`和`anchor2`：

```html{5,9}
<div class="container">
  <p>内容</p>
  <p style="margin-bottom: 400px">内容</p>
  <!-- 全是内容         -->
  <h1 id="anchor1">锚点一</h1>
  <p>内容</p>
  <p style="margin-bottom: 400px">内容</p>
  <!-- 全是内容         -->
  <h1 id="anchor2">
    <a href="#anchor2">锚点二</a>
  </h1>
  <p>内容</p>
  <p style="margin-bottom: 900px">内容</p>
  <!-- 全是内容         -->
</div>
```

当我们访问带有锚链(`fragment`)的`url`地址，比如，我们直接访问带有`anchor1`的锚链时：

```bash
http://www.xxx.com/#anchor1  # 锚链(fragment)为#anchor1；
```

页面便可直接定位到**锚链一**，但此时我们会发现，其过程是直接跳转过去的，这使得用户体验相当的生硬。

此时我们可以在滚动条容器中加上一行`css`代码(这里是 html)：`scroll-behavior: smooth;`，页面便会以一定速度平滑滚动至锚点；

```html
<html lang="en" style="scroll-behavior: smooth;">
  ...
</html>
```

![基础的锚点点位](https://article-1256327087.cos.ap-beijing.myqcloud.com/anchor/iShot_2023-02-07_14.30.18.gif)

而当我们点击锚点二的时候，

```html{2}
<h1 id="anchor2">
  <a href="#anchor2">锚点二</a>
</h1>
```

`a`标签中的`href`值为`#anchor2`，这将设置为`url`中的`hash`值，即此时页面的锚链(`fragment`)将会设置为`#anchor2`，当前锚点二，将会直接平滑滚动至浏览器顶部；

### 锚点定位流程

[`wahtwg`](https://html.spec.whatwg.org/multipage/browsing-the-web.html#scrolling-to-a-fragment)中有详细流程说明：

首先我们要理解几个概念：

- 指示部分(`indicated part `)：其指代`URL`中的`hash`值，即`fragment`锚链，如果不存在锚链，则为`null`
- 目标元素(`target Element`)：每个`Document`都拥有一个`target Element`，主要用于`:target`伪元素进行算法更新，初始值为 null；

要滚动至`html`中给定文档片段`fragment`(锚链)：

1. 如果`document`的指示部分为空，则将 `document`的目标元素设置为空。
2. 否则，如果`document`的指示部分位于`document`的顶部，则：
   1. 将`document`的目标元素设置为空。
   2. 滚动到 `document`的开头。[CSSOMVIEW]
   3. `return`
3. 否则：
   1. 断言：`document`的指示部分是一个`element`元素。
   2. 使目标成为`document`的指定部分。
   3. 将文档的目标元素设置为`target`(锚点)。
   4. 在`target`(锚点)上运行祖先细节揭示算法。
   5. 在 `target`(锚点)上运行祖先 hidden-until-found 揭示算法。
   6. 将`target`(锚点)滚动到视图中，行为设置为`auto`，`block`设置为`start`，`inline` 设置为`nearest`。[CSSOMVIEW]
   7. 运行`target`(锚点)的聚焦步骤，将`Document`的视口作为后备目标。
   8. 将顺序焦点导航起点移动到 `target`。

而如何确认指示部分(`indicated part`)：

1. 设`fragment`为文档的 URL 片段。\_
2. 如果`fragment`是空字符串，则返回特殊值`top of the document`。
3. 设`potentialIndicatedElement`为给定`document`和 `fragment`找到潜在指示元素的结果。
4. 如果`potentialIndicatedElement`不为空，则返回 `potentialIndicatedElement`。
5. 使用`percent-decoding`解码`fragment`为`fragmentBytes`。
6. 让`decodedFragment`成为在 `fragmentBytes` 上运行不带`BOM` 的 `UTF-8` 解码的结果。
7. 将`potentialIndicatedElement`设置为在给定`document`和 `decodedFragment`的情况下找到潜在指示元素的结果。
8. 如果`potentialIndicatedElement`不为空，则返回` potentialIndicatedElement`。
9. 如果`decodedFragment`是字符串的`ASCII` 不区分大小写的匹配项`top`，则返回文档的顶部。
10. 返回空值。

最后，如何去找到`potential indicated element`，即我们的**锚点**：

1. 如果文档树中有一个根为`document`且`ID`等于`fragment`的元素，则按`tree order`返回第一个这样的元素。
2. 如果文档树中有一个`a`标签，并且其根为`document`，其`name`属性值等于`fragment` ，则按`tree order`返回第一个这样的元素
3. `return null`。

因此，你还可以得知：

```html
<a name="anchor">只要name等于锚链的a标签，即为锚点</a>
<h1 id="anchor">只要id等于锚链，即为锚点</h1>
```

当他俩同时出现时，以`id`为锚点的元素，将会成为`potential indicated element`，而不是第一个出现的锚点(即便他俩都可以当做锚点)

## 锚点目录

现在我们要在页面中实现一个目录，这里我使用了`vue3`：

```html
<div id="app" class="container">
  <!-- 文章详情 -->
  <article>
    <template v-for="(item,index) in num">
      <p style="margin-bottom: 200px">内容</p>
      <h1>
        <a :name="`anchor${index}`" :href="`#anchor${index}`">锚点{{index}}</a>
      </h1>
    </template>
    <p style="margin-bottom: 900px">内容</p>
  </article>
  <!-- 锚点目录 -->
  <ul style="position: fixed; top: 0; right: 0;width: 200px;">
    <li v-for="(item,index) in num">
      <a :name="`anchor${index}`" :href="`#anchor${index}`">锚点{{index}}</a>
    </li>
  </ul>
</div>
<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
<script>
  const { createApp, ref } = Vue
  createApp({
    setup(props) {
      const num = ref(8)
      return {
        num
      }
    }
  }).mount('#app')
</script>
```

![基本的锚点目录跳转](https://article-1256327087.cos.ap-beijing.myqcloud.com/anchor/iShot_2023-02-07_16.30.13.gif)

### 点亮状态

再进行点亮状态的记录：

```html{5,7,22-24}
<!-- 省略代码 -->
<ul style="position: fixed; top: 0; right: 0; width: 200px">
  <li v-for="(item, index) in num">
    <a
      @click="handlerActive(index)"
      :class="{
        active:'#anchor'+index === active
      }"
      :name="`anchor${index}`"
      :href="`#anchor${index}`"
      >锚点{{index}}</a
    >
  </li>
</ul>
<!-- 省略代码 -->
<script>
  const { createApp, ref } = Vue
  createApp({
    setup(props) {
      const num = ref(8)
      const active = ref()
      const handlerActive = (index) => {
        active.value = `#anchor${index}`
      }
      return {
        num,
        active,
        handlerActive
      }
    }
  }).mount('#app')
</script>
```

加点样式：

```html
<style>
  ul li .active {
    background-color: aqua;
  }
</style>
```

其实还有一步需要处理，即刷新时，如果`url`中带有锚链，则将`active`值设置为当前锚链。

这一步我们没有必要提前做，我们只要完成**滚动点亮目录**，那右侧目录将会自动根据滚动条进行点亮；

### 滚动分析

即，锚点出现在视窗顶部时，自动点亮右侧目录对应的条目：

![image](https://article-1256327087.cos.ap-beijing.myqcloud.com/anchor/iShot_2023-02-03_15.47.58.gif)

业内目前较为常用的便是交叉观察器`IntersectionObserver`来实现检测一个目标，是否出现在视窗中，使用这个`API`这很容易实现滚动点亮目录需求，但其具有一些问题：

1. 兼容性问题——可以使用`polifill`来解决，而`polifill`是具有一定体积的
2. `IntersectionObserver`为异步执行，这将会导致滚动条滑动过快时，将不会执行相关任务；

`IntersectionObserver`设计目标主要是检测一个元素是否对人眼可见，如果我们用于滚动点亮目录需求，确有些不恰当，我们无法接受滚动条过快，而不执行目录点亮操作：因为，左侧文章的快速滚动人眼可能不可见（即不触发`IntersectionObserver`的回调），但对应到右侧目录的点亮来说，其变化状态实则是肉眼可见的，因此是需要连续不断的变更点亮状态；

因此`IntersectionObserver`并不太适合用于实现**滚动点亮目录**需求。

我们可以采用监听`scroll`事件，实时计算各个锚点在视觉窗口位置，从而点亮右侧目标；但需要避免大量的计算，从而导致浏览器 js 阻塞问题；以下方案便避免了当前问题；

### 具体实现

大致实现思路为：

1. 在页面加载完毕时，便获取各个锚点的位置信息；
2. 监听滚动事件，实时获取`scrollTop`值
3. 将`scrollTop`值，与内存变量中的锚点位置信息进行对比
4. 从而进行点亮右侧目录

> 注意，以下`js`代码，默认存在于`setup(){/.../}`方法中，并默认`return`

对正文中的锚点，增加标志信息`data-target-id`；

```html{2}
<a
  :data-target-id="`anchor${index}`"
  :name="`anchor${index}`"
  :href="`#anchor${index}`">
 锚点{{index}}
</a>
```

在`onMouted`中，记录左侧文章内容中的锚点位置信息：

```js
const articleAnchors = []
const initAnc = () => {
  const targetDoms = document.querySelectorAll('[data-target-id]')
  targetDoms.forEach((dom) => {
    articleAnchors.push({
      dom: dom,
      // 获取当前dom距离文档流顶部的距离
      // -1的目的是为了滚动到当前offsetTop值时，视窗顶部正好盖住1px的锚点元素，这样才能正确激活右侧目录
      offsetTop: getElementTop(dom) - 1,
      id: dom.dataset.fragmentId
    })
  })
  articleAnchors.sort((a, b) => a.offsetTop - b.offsetTop)
}
onMounted(() => {
  initAnc()
})
```

以上代码中的`getElementTop`是为了获取一个元素距离文档顶部的位置信息，理应使用`element.offsetTop`来获取，但因为其指受`offsetParent`影响，因此需要递归累加`offsetTop`的值，以此正确的拿到当前锚点距离文档流顶部的距离，具体可仔细阅读[`offsetParent`的描述](https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/offsetParent)；

```js
// 获取Element的offsetTop，忽略offsetParent的影响
function getElementTop(element) {
  let actualTop = element.offsetTop
  let current = element.offsetParent
  while (current !== null) {
    actualTop += current.offsetTop
    current = current.offsetParent
  }
  return actualTop
}
```

最后，监听`scroll`事件，并在`articleAnchors`位置信息中，寻找对应的锚点详细信息，以此点亮右侧的目录条目；

```js
const scrollTop = ref(0)
const scrollBehavior = () => {
  // 获取滚动条高度兼容性写法
  scrollTop.value =
    document.documentElement.scrollTop ||
    window.pageYOffset ||
    document.body.scrollTop
  // 二分法在一个有序数组中查找对应值
  const anc = searchAnchor(articleAnchors, scrollTop.value)
  if (anc) {
    active.value = `#${anc.id}`
  } else {
    active.value = undefined
  }
}
onMounted(() => {
  initAnc()
  window.addEventListener('scroll', scrollBehavior)
})

onBeforeUnmount(() => {
  // 退出时停止监听
  window.removeEventListener('scroll', scrollBehavior)
})
```

其中查找位置信息中用到了二分法，二分法适用于在有序数组中，查找对应的值；

```js
/**
 * 二分法查找值
 */
function searchAnchor(anchors, target) {
  let left = 0
  let right = anchors.length - 1
  while (left <= right) {
    const mid = Math.floor((left + right) / 2)
    if (anchors[mid].offsetTop < target) {
      left = mid + 1
    } else if (anchors[mid].offsetTop > target) {
      right = mid - 1
    } else {
      return anchors[mid]
    }
  }
  return anchors[right]
}
```

此时，已基本完成整体需求；

![基础实现](https://article-1256327087.cos.ap-beijing.myqcloud.com/anchor/iShot_2023-02-07_18.35.57.gif)

还有一个问题，为什么不使用`getBoundingClientRect()`方案来获取每一个锚点的位置信息，如果使用这个`API`最主要的原因便是，当前`API`将会在主线程上执行，配合`scroll`事件监听，如果不进行节流等额外处理，将会导致事件阻塞问题。但节流又会导致降低了滚动实时性，也就是说同样会出现，滚动过快，右侧某些条目被跳过的情况；

> - 节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效
> - 防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时

## 实际应用

虽然完成了一个看似还不错的 demo，但是在实际情况中使用，还是会出现一些问题，如：

- 正文中有内容的高度变化，从而导致`articleAnchors`中的位置信息记录不准确而过期；
- 锚点定位呗`fixed`的元素遮挡的解决方案
- 服务端渲染如`nuxt3`架构下，会使得浏览器默认的锚点定位流程触发时机过早，而`js`又尚未被**激活**，则`scroll`事件还未被注册，因此导致前目录中前几个条目无法被点亮，而滚动条会在滚动到一定距离后，闪动一下；

### 高度变化

有很多情况都会导致文档流的高度变化，如窗口缩小导致文字换行、图片加载出来晚于位置信息的计算、接口返回数据后填充内容等情况，但他并不是一个频繁触发的场景。

可能很多伙伴第一想法便是使用`window.onresize`，但他仅能检测`window`的窗口变化；

这里我们使用`MutationObserver`来进行监听`document.documentElement`的高度变化，次`API`是一个异步触发操作，也就是说`DOM`的变动并不会马上触发，而是要等到当前所有`DOM`操作都结束后才触发；

这里我使用了`vueuse`的库：

```js
import { useResizeObserver } from '@vueuse/core'
// 更新位置信息
const updateAncData = () => {
  articleAnchors.map((i) => {
    i.offsetTop = getElementTop(i.dom) - 1
    return i
  })
}

const wrapperHeight = ref(0)
const { stop } = useResizeObserver(document.documentElement, (entries) => {
  const entry = entries[0]
  const { height } = entry.contentRect
  // 记录文档高度
  wrapperHeight.value = height
})

// 文档高度一旦繁盛改变，则更新文档中锚点的位置
watch(wrapperHeight, () => {
  updateAncData()
})

onBeforeUnmount(() => {
  // 退出时停止监听
  stop()
  window.removeEventListener('scroll', scrollBehavior)
})
```

### fixed 遮盖

有 5 种方案可以解决：

- 滚动容器元素上设置`scroll-padding-top`值等于遮盖的高度
- `padding-top:遮盖高度;margin-top:负的遮盖高度`设置于锚点元素上
- 锚点使用内联元素如`a`标签、`span`标签，并设置`padding-top`等于遮盖的高度
- 暗锚点————使用一个肉眼不可见的元素，定位至锚点元素上部`top=遮盖高度`处，从而使得浏览器自身滚动直接触达隐藏的暗锚点处
- `:target`伪类，锚链将会触发伪类的样式，因此可以在此伪类`css`上，设置遮盖高度的`margin`值

缺点总结：

- `scroll-padding-top`的设置，会影响到全局，因此直接否了
- `padding + margin`会导致无法复制文档的问题
- 内联元素————使得布局的变动(如锚点想要做一些样式变更)，可能会产生一些问题
- `:target`伪类，由于本文的方案中，需要记录锚点位置信息，因此每一次`:target`的样式触发，都会导致高度变化，因此否了；
- 暗锚点：采用此方案，暂无发现别的问题；

### 服务端渲染中

服务端渲染中，会使得浏览器默认的锚点定位流程触发时机过早，而`js`又尚未被**激活**，则`scroll`事件还未被注册，因此导致前目录中前几个条目无法被点亮，而滚动条会在滚动到一定距离后，闪动一下；

![同构渲染](https://article-1256327087.cos.ap-beijing.myqcloud.com/anchor/%E5%9B%BE%E7%89%871.png)

此问题是在`nuxt3`同构渲染中发现的，以上为同构渲染加载图，其有很多优势，但`TTI`时间过长使得，本方案出现了这个问题。其中`FCP`即首屏时间很短，但可交互时间`TTI`变得较长。

`TTI`即可交互时间(`Time to Interactive`)，指标测量页面从开始加载到主要子资源完成渲染，并能够快速、可靠地响应用户输入所需的时间。

服务器端渲染 (SSR) 等技术可能会导致页面看似具备交互性（即，链接和按钮在屏幕上可见），但实际上并不能进行交互，因为主线程被阻塞或是因为控制这些元素的 `JavaScript` 代码尚未完成加载。

思路转变一下，我们禁止默认的浏览器锚点定位行为，而采用自定义锚点，再通过`scrollIntoView`方法，使得页面滚动至锚点的位置；

- 去除正文中的`name`属性，使其不被浏览器识别为一个锚点，从而不会触发浏览器的锚点链接行为

```html{3}
<a
  :data-target-id="`anchor${index}`"
- :name="`anchor${index}`"
  :href="`#anchor${index}`"
  >锚点{{index}}</a
>
```

- 监听 `hash` 值的改变，将该页面平滑滚动到该锚链指向得锚点处

```js{15}
import { useRouteHash } from '@vueuse/router'
const search = useRouteHash()

watch(
  () => search.value,
  (val) => {
    goAnchorTarget(val)
  }
)

const goAnchorTarget = (val: string) => {
  if (val) {
    const target = articleAnchors.find((i) => `#${i.id}` === val)
    if (target) {
      target.dom.scrollIntoView({
        behavior: 'smooth'
      })
    }
  }
}

onMounted(() => {
  goAnchorTarget(search.value)
})
```
关于`scrollIntoView`方法会滚动元素的父容器，使被调用 `scrollIntoView()` 的元素对用户可见。

具体得使用方式本文不再阐述；

![scrollIntoView兼容性问题](https://article-1256327087.cos.ap-beijing.myqcloud.com/anchor/jianrongxing.png)

## 参考资料

- [URL 锚点 HTML 定位技术机制、应用与问题](https://www.zhangxinxu.com/wordpress/2013/08/url-anchor-html-%E9%94%9A%E7%82%B9%E5%AE%9A%E4%BD%8D%E6%9C%BA%E5%88%B6-%E5%BA%94%E7%94%A8-%E9%97%AE%E9%A2%98/)
- [滚动至锚点的行为流程](https://html.spec.whatwg.org/multipage/browsing-the-web.html#scroll-to-fragid)
- [滚动行为](https://html.spec.whatwg.org/multipage/browsing-the-web.html#scrolling-to-a-fragment)